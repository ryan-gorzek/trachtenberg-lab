---
title: "R Notebook"
output: html_notebook
---

```{r}

library(Seurat)
library(SeuratDisk)
library(reticulate)
library(scrubletR)
library(ggplot2)
library(patchwork)
library(dplyr)
library(data.table)
library(clustree)
library(reshape2)
library(tidyr)
library(gridExtra)
library(stringr)
library(plyr)
source("C:/Ryan/GitHub/trachtenberg-lab/transcriptomics/tools/seurat_functions.R")
source("C:/Ryan/GitHub/trachtenberg-lab/transcriptomics/tools/seurat_integration_functions.R")
source("C:/Ryan/GitHub/trachtenberg-lab/transcriptomics/xgboost/xgboost_train.R")
source("C:/Ryan/GitHub/trachtenberg-lab/transcriptomics/xgboost/plottingFxns.R")
colors_list <- GetColors()

obj.mouse.glutamatergic <- readRDS("E:/Transcriptomics_V1/Mouse/seurat/mouse_v1_P38_glutamatergic_processed.rds")
obj.mouse.glutamatergic$class <- "glutamatergic"
obj.opossum.glutamatergic <- readRDS("E:/Transcriptomics_V1/Opossum/seurat/opossum_v1_glutamatergic_processed.rds")
obj.opossum.glutamatergic$class <- "glutamatergic"

```


```{r}

obj.mouse.IT <- subset(obj.mouse.glutamatergic, subclass %in% c("L2/3", "L4", "L5IT", "L6IT"))
obj.opossum.IT <- subset(obj.opossum.glutamatergic, subclass %in% c("IT_A", "IT_B", "IT_C", "IT_D"))

```


```{r}

# Correlate class-level gene-expression patterns across Seurat objects using HVGs
# - Computes class-wise average expression (per class = mean of log-normalized "data" slot)
# - Restricts genes to HVGs (union across objects by default, or user-supplied)
# - Returns a correlation matrix of classes vs classes
# Dependencies: Seurat (v4+), dplyr, Matrix, purrr, tibble, tidyr

suppressPackageStartupMessages({
  library(Seurat)
  library(dplyr)
  library(Matrix)
  library(purrr)
  library(tibble)
  library(tidyr)
})

# avg expression per class from a Seurat object
.avg_expr_by_group <- function(obj, group_col, genes = NULL, assay = NULL) {
  if (is.null(assay)) assay <- DefaultAssay(obj)
  mat <- GetAssayData(obj, assay = assay, slot = "data")  # log-normalized recommended
  md  <- obj@meta.data
  stopifnot(group_col %in% colnames(md))
  groups <- droplevels(factor(md[[group_col]]))
  if (!is.null(genes)) {
    genes <- intersect(genes, rownames(mat))
    mat <- mat[genes, , drop = FALSE]
  }
  # fast group means: split column indices by group, then rowMeans
  idx_list <- split(seq_len(ncol(mat)), groups)
  means_list <- lapply(names(idx_list), function(g) {
    idx <- idx_list[[g]]
    if (length(idx) == 1L) {
      as.numeric(mat[, idx])
    } else {
      Matrix::rowMeans(mat[, idx, drop = FALSE])
    }
  })
  M <- do.call(cbind, means_list)
  colnames(M) <- names(idx_list)
  M
}

# main: correlate classes across 1+ Seurat objects
CorrelateClassesHVG <- function(
  seurat_list,
  group_cols,                # named character vector: names(seurat_list) -> group column in that object
  class_keep = NULL,         # optional named list: names(seurat_list) -> character vector of classes to keep
  hvgs = NULL,               # optional character vector of genes to use; if NULL, union of VariableFeatures across objs
  hvgs_n = 2000,             # if hvgs is NULL and some objects lack VariableFeatures, compute with FindVariableFeatures
  assay = NULL,              # per-object default assay; if NULL uses each object's DefaultAssay
  cor_method = c("pearson", "spearman"),
  scale_by_gene = FALSE      # if TRUE, z-score genes (rows) before correlation
) {
  cor_method <- match.arg(cor_method)

  # ensure list
  if (inherits(seurat_list, "Seurat")) {
    seurat_list <- list(obj1 = seurat_list)
    if (length(group_cols) == 1 && is.null(names(group_cols))) {
      names(group_cols) <- "obj1"
    }
  }
  stopifnot(is.list(seurat_list), length(seurat_list) >= 1)

  # collect HVGs if not provided
  if (is.null(hvgs)) {
    hvgs_vec <- character()
    for (nm in names(seurat_list)) {
      obj <- seurat_list[[nm]]
      v <- VariableFeatures(obj)
      if (length(v) == 0L) {
        # compute HVGs if absent
        obj <- suppressWarnings(FindVariableFeatures(obj, nfeatures = hvgs_n))
        seurat_list[[nm]] <- obj
        v <- VariableFeatures(obj)
      }
      hvgs_vec <- union(hvgs_vec, v)
    }
    hvgs <- hvgs_vec
  }

  # build class-average matrices for each object
  mats <- list()
  class_labels <- character()
  for (nm in names(seurat_list)) {
    obj <- seurat_list[[nm]]
    gcol <- group_cols[[nm]]
    stopifnot(!is.null(gcol), gcol %in% colnames(obj@meta.data))

    # filter to kept classes if provided
    if (!is.null(class_keep) && !is.null(class_keep[[nm]])) {
      keep <- intersect(levels(factor(obj@meta.data[[gcol]])), class_keep[[nm]])
      cells_keep <- rownames(obj@meta.data)[obj@meta.data[[gcol]] %in% keep]
      obj <- subset(obj, cells = cells_keep)
    }

    M <- .avg_expr_by_group(obj, group_col = gcol, genes = hvgs, assay = assay)
    # prefix columns by object name to keep identities distinct
    colnames(M) <- paste0(nm, "::", colnames(M))
    mats[[nm]] <- M
    class_labels <- c(class_labels, colnames(M))
  }

  # intersect genes present across all matrices
  common_genes <- Reduce(intersect, lapply(mats, rownames))
  if (length(common_genes) < 10) stop("Fewer than 10 shared genes across inputs; check gene IDs or assays.")
  mats <- lapply(mats, function(M) M[common_genes, , drop = FALSE])

  # combine gene x class matrix
  E <- do.call(cbind, mats)  # genes x classes
  if (scale_by_gene) {
    # z-score per gene (row)
    E <- t(scale(t(E)))
    # handle constant rows (NA after scaling)
    E[is.na(E)] <- 0
  }

  # correlation across classes (columns) using genes as observations
  C <- suppressWarnings(cor(E, method = cor_method, use = "pairwise.complete.obs"))
  # order rows/cols alphabetically for determinism
  C <- C[order(rownames(C)), order(colnames(C)), drop = FALSE]

  list(
    cor_mat = C,                    # class-by-class correlation matrix
    genes_used = common_genes,      # HVGs actually used (intersection across objects)
    class_order = colnames(C)
  )
}

# ---------------------------
# Minimal example (replace objects/metadata with your own):
# Assume:
#   obj.mouse with meta$subclass including "L2/3","L4"
#   obj.opossum with meta$subclass including "IT_A","IT_B"
# Both objects are already NormalizeData()'d and (optionally) FindVariableFeatures()'d.

# Example usage:
res <- CorrelateClassesHVG(
  seurat_list = list(mouse = obj.mouse.IT, opossum = obj.opossum.IT),
  group_cols  = c(mouse = "subclass", opossum = "subclass"),
  class_keep  = list(mouse = c("L2/3", "L4", "L5IT", "L6IT"), opossum = c("IT_A", "IT_B", "IT_C", "IT_D")),
  hvgs        = NULL,           # use union of VariableFeatures across inputs
  hvgs_n      = 3000,           # if HVGs need to be computed
  cor_method  = "spearman",
  scale_by_gene = TRUE          # recommended when comparing across species
)

```


```{r}

# Scatter of within-species subclass-pair correlations:
#   x-axis = mouse pairwise correlation
#   y-axis = opossum pairwise correlation
# Requires: a class-by-class correlation matrix from CorrelateClassesHVG()

suppressPackageStartupMessages({
  library(dplyr)
  library(tidyr)
  library(tibble)
  library(ggplot2)
  library(ggrepel)
  library(stringr)
})

# mapping: named character vector, names = opossum subclasses, values = mouse subclasses
#   e.g., c("IT_A"="L2/3","IT_B"="L4","IT_C"="L5IT","IT_D"="L6IT")
# species tags must match the prefixes you used in CorrelateClassesHVG() colnames, e.g., "opossum::", "mouse::"
PlotWithinSpeciesPairCorrScatter <- function(
  cor_mat,
  mapping,
  opp_tag   = "opossum",
  mouse_tag = "mouse",
  label_points = TRUE
) {
  stopifnot(is.matrix(cor_mat), length(mapping) >= 2)

  # helper to build full labels like "opossum::IT_A"
  .lab <- function(tag, cls) paste0(tag, "::", cls)

  # keep only classes present in cor_mat
  opp_keep   <- names(mapping)[.lab(opp_tag, names(mapping)) %in% colnames(cor_mat)]
  mouse_keep <- unname(mapping)[.lab(mouse_tag, unname(mapping)) %in% colnames(cor_mat)]
  mapping    <- setNames(mouse_keep, opp_keep)
  if (length(mapping) < 2) stop("Fewer than 2 mapped subclasses found in cor_mat after filtering.")

  # species-specific submatrices
  opp_cols   <- intersect(colnames(cor_mat), .lab(opp_tag, names(mapping)))
  mouse_cols <- intersect(colnames(cor_mat), .lab(mouse_tag, unname(mapping)))
  C_opp      <- cor_mat[opp_cols,  opp_cols,  drop = FALSE]
  C_mouse    <- cor_mat[mouse_cols, mouse_cols, drop = FALSE]

  # consistent order
  opp_order   <- names(mapping)
  mouse_order <- unname(mapping)
  C_opp   <- C_opp[.lab(opp_tag,   opp_order),   .lab(opp_tag,   opp_order),   drop = FALSE]
  C_mouse <- C_mouse[.lab(mouse_tag, mouse_order), .lab(mouse_tag, mouse_order), drop = FALSE]

  # build all unordered pairs i<j in this aligned order
  pairs_idx <- which(upper.tri(matrix(NA, nrow = length(mapping), ncol = length(mapping))), arr.ind = TRUE)
  df <- tibble(
    opp_1   = opp_order[pairs_idx[,1]],
    opp_2   = opp_order[pairs_idx[,2]],
    mouse_1 = mouse_order[pairs_idx[,1]],
    mouse_2 = mouse_order[pairs_idx[,2]]
  ) %>%
    mutate(
      opp_corr   = mapply(function(a,b) C_opp[.lab(opp_tag,a),   .lab(opp_tag,b)],   opp_1, opp_2),
      mouse_corr = mapply(function(a,b) C_mouse[.lab(mouse_tag,a), .lab(mouse_tag,b)], mouse_1, mouse_2),
      pair_opp   = paste0(opp_1, " / ", opp_2),
      pair_mouse = paste0(mouse_1, " / ", mouse_2),
      pair_label = paste0(pair_opp, "  |  ", pair_mouse)
    )

  # plot
  p <- ggplot(df, aes(x = mouse_corr, y = opp_corr)) +
    geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
    geom_point(size = 3) +
    coord_equal(xlim = c(0.25, 0.65), ylim = c(0.25, 0.65), expand = FALSE) +
    labs(
      x = paste0(str_to_title(mouse_tag), " within-species subclass-pair correlation"),
      y = paste0(str_to_title(opp_tag),   " within-species subclass-pair correlation"),
      title = "Subclass-pair correlation concordance: Mouse (x) vs Opossum (y)"
    ) +
    theme_classic(base_size = 12)

  if (label_points) {
    p <- p + ggrepel::geom_text_repel(aes(label = pair_label), size = 3, max.overlaps = Inf)
  }

  list(data = df, plot = p)
}

# ---------------------------
# Example (adjust names to your objects/labels):
# Suppose you used:
#   mouse subclasses: "L2/3","L4","L5IT","L6IT"
#   opossum subclasses: "IT_A","IT_B","IT_C","IT_D"
# After running CorrelateClassesHVG() into `res`:

mapping <- c("IT_A"="L2/3", "IT_B"="L4", "IT_C"="L5IT", "IT_D"="L6IT")

out <- PlotWithinSpeciesPairCorrScatter(
  cor_mat = res$cor_mat,
  mapping = mapping,
  opp_tag = "opossum",
  mouse_tag = "mouse",
  label_points = TRUE
)

# svg("E:/Opossum_Paper/Figure 2/Cross_Subclass_Corr.svg", width = 6, height = 6)
out$data   # table of pairs and correlations
print(out$plot)

```












```{r}

obj.mouse.IT <- subset(obj.mouse.glutamatergic, subclass %in% c("L2/3", "L4", "L5IT"))
obj.opossum.IT <- subset(obj.opossum.glutamatergic, SCT_snn_res.0.3 %in% c(1, 3, 4, 5, 6, 8))
obj.opossum.IT$SCT_snn_res.0.3[obj.opossum.IT$SCT_snn_res.0.3 == 8] <- 4
obj.opossum.IT$SCT_snn_res.0.3[obj.opossum.IT$SCT_snn_res.0.3 == 3] <- 2
obj.opossum.IT$SCT_snn_res.0.3[obj.opossum.IT$SCT_snn_res.0.3 == 5] <- 8 # Temp for 5
obj.opossum.IT$SCT_snn_res.0.3[obj.opossum.IT$SCT_snn_res.0.3 == 6] <- 5
obj.opossum.IT$SCT_snn_res.0.3[obj.opossum.IT$SCT_snn_res.0.3 == 8] <- 6
# Idents(obj.opossum.IT) <- "SCT_snn_res.0.2"
# degs <- FindAllMarkers(obj.opossum.IT, only.pos = T)
# degs$cluster <- as.character(degs$cluster)
# for (cl in unique(degs$cluster)) {
# degs_cl <- degs[degs$cluster == cl, ]
# print(degs_cl %>%
#   summarise(
#     frac_op = mean(grepl("^ENSMODG", gene))
#   ))
# }

```


```{r}


res$cor_mat  # matrix; rows/cols are "object::class", e.g., "mouse::L2/3" vs "opossum::IT_A"

pheatmap::pheatmap(res$cor_mat, clustering_method = "average", border_color = NA)

# # Helper to order labels by class_keep if you used it
# .order_by_keep <- function(cnames, species, keep_vec = NULL) {
#   lab <- grep(paste0("^", species, "::"), cnames, value = TRUE)
#   if (is.null(keep_vec)) return(lab)
#   desired <- paste0(species, "::", keep_vec)
#   intersect(desired, lab)  # keeps only those present, in given order
# }
# 
# # Extract cross-species block
# mouse_labs   <- .order_by_keep(colnames(res$cor_mat), "mouse",   keep_vec = c("L2/3","L4","L5IT"))
# opossum_labs <- .order_by_keep(colnames(res$cor_mat), "opossum", keep_vec = c("1","2","4","5"))
# 
# cross_mat <- res$cor_mat[mouse_labs, opossum_labs, drop = FALSE]
# 
# # Heatmap
# pheatmap::pheatmap(
#   cross_mat,
#   clustering_distance_rows = "euclidean",
#   clustering_distance_cols = "euclidean",
#   clustering_method = "average",
#   display_numbers = FALSE,
#   border_color = NA,
#   main = "Mouse (rows) vs Opossum (cols): HVG expression pattern correlations"
# )

```


```{r}

# Example usage:
res <- CorrelateClassesHVG(
  seurat_list = list(mouse = obj.mouse.IT, opossum = obj.opossum.IT),
  group_cols  = c(mouse = "subclass", opossum = "SCT_snn_res.0.3"),
  class_keep  = list(mouse = c("L2/3", "L4", "L5IT"), opossum = c(1, 2, 4, 5, 6)),
  hvgs        = NULL,           # use union of VariableFeatures across inputs
  hvgs_n      = 3000,           # if HVGs need to be computed
  cor_method  = "spearman",
  scale_by_gene = TRUE          # recommended when comparing across species
)
res$cor_mat  # matrix; rows/cols are "object::class", e.g., "mouse::L2/3" vs "opossum::IT_A"

# pheatmap::pheatmap(res$cor_mat, clustering_method = "average", border_color = NA)

# Helper to order labels by class_keep if you used it
.order_by_keep <- function(cnames, species, keep_vec = NULL) {
  lab <- grep(paste0("^", species, "::"), cnames, value = TRUE)
  if (is.null(keep_vec)) return(lab)
  desired <- paste0(species, "::", keep_vec)
  intersect(desired, lab)  # keeps only those present, in given order
}

# Extract cross-species block
mouse_labs   <- .order_by_keep(colnames(res$cor_mat), "mouse",   keep_vec = c("L2/3", "L4", "L5IT"))
opossum_labs <- .order_by_keep(colnames(res$cor_mat), "opossum", keep_vec = c(1, 2, 5))

cross_mat <- res$cor_mat[mouse_labs, opossum_labs, drop = FALSE]

# Heatmap
# svg("E:/Opossum_Paper/Figure S3/Cluster_Subclass_Mapping.svg", width = 6, height = 5)
pheatmap::pheatmap(
  cross_mat,
  clustering_distance_rows = "euclidean",
  clustering_distance_cols = "euclidean",
  clustering_method = "average",
  display_numbers = FALSE,
  border_color = NA,
  main = "Mouse (rows) vs Opossum (cols): HVG expression pattern correlations",
  color = colorRampPalette(c("white", "red"))(100)
)
# dev.off()

```


```{r}

# Example usage:
res <- CorrelateClassesHVG(
  seurat_list = list(mouse = obj.mouse.IT, opossum = obj.opossum.IT),
  group_cols  = c(mouse = "subclass", opossum = "subclass"),
  class_keep  = list(mouse = c("L2/3", "L4", "L5IT"), opossum = c("IT_A", "IT_B", "IT_C")),
  hvgs        = NULL,           # use union of VariableFeatures across inputs
  hvgs_n      = 3000,           # if HVGs need to be computed
  cor_method  = "pearson",
  scale_by_gene = TRUE          # recommended when comparing across species
)
res$cor_mat  # matrix; rows/cols are "object::class", e.g., "mouse::L2/3" vs "opossum::IT_A"

pheatmap::pheatmap(res$cor_mat, clustering_method = "average", border_color = NA)

# Helper to order labels by class_keep if you used it
.order_by_keep <- function(cnames, species, keep_vec = NULL) {
  lab <- grep(paste0("^", species, "::"), cnames, value = TRUE)
  if (is.null(keep_vec)) return(lab)
  desired <- paste0(species, "::", keep_vec)
  intersect(desired, lab)  # keeps only those present, in given order
}

# Extract cross-species block
mouse_labs   <- .order_by_keep(colnames(res$cor_mat), "mouse",   keep_vec = c("L2/3", "L4", "L5IT"))
opossum_labs <- .order_by_keep(colnames(res$cor_mat), "opossum", keep_vec = c("IT_A", "IT_B", "IT_C"))

cross_mat <- res$cor_mat[mouse_labs, opossum_labs, drop = FALSE]

# Heatmap
pheatmap::pheatmap(
  cross_mat,
  clustering_distance_rows = "euclidean",
  clustering_distance_cols = "euclidean",
  clustering_method = "average",
  display_numbers = FALSE,
  border_color = NA,
  main = "Mouse (rows) vs Opossum (cols): HVG expression pattern correlations"
)

```











